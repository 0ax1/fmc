#!/usr/bin/env zsh
# fmc: https://github.com/0ax1/fmc

# Echo the revision range to inspect. In case the current branch is not main,
# the range is given by the common ancestor with main and the current branch's
# HEAD. Otherwise, all commits of main are taken into account.
rev_range() {
    if [[ ! -z "`git branch --list main`" && `git rev-parse --abbrev-ref HEAD` != "main" ]]; then
        echo "`git merge-base HEAD main`..HEAD"
    elif [[ ! -z "`git branch --list master`" && `git rev-parse --abbrev-ref HEAD` != "master" ]]; then
        echo "`git merge-base HEAD master`..HEAD"
    else
        echo "HEAD"
    fi
}

# Echo the hunk range in the format: [start-line, end-line].
hunk_range() {
    # Hunk format: @@ -del[,line_count] +add[,line_count] @@
    local preprocess() { echo $1 | grep -oE '[,0-9]*' }
    local readonly first_lines=(`preprocess $1 | sed 's/,[0-9]*//g'`)
    local last_lines=(`preprocess $1 | sed 's/,/\+/g'`)

    for i (1 2); do
        # Calculate last line as (start + count - 1).
        (( last_lines[i] = last_lines[i] ))
        # Check if the line count was zero or empty.
        if [[ $last_lines[$i] -gt $first_lines[$i] ]]; then
            (( last_lines[i] -= 1 ))
        fi
    done

    if [[ $last_lines[1] -gt $last_lines[2] ]]; then
        echo "$first_lines[1] $last_lines[1]"
    else
        echo "$first_lines[2] $last_lines[2]"
    fi
}

# List line matching commits prefixed with 'L '.
line_candidates() {
    # Iterate files which have been modified.
    (for file in `git diff --name-only --staged --diff-filter=M`; do
        local readonly last_line=`git show HEAD:$file | wc -l`

        # Hunk format: @@ -del[,line_count] +add[,line_count] @@
        (git diff --staged -U0 $file | grep -E '^@@ ') | while read hunk; do
            local range=(`hunk_range $hunk`)

            # Check for appended lines which cannot be blamed.
            if [[ $range[2] -le $last_line ]]; then
                range="$range[1],$range[2]"
                git blame -s -b --root --no-progress -L $range `rev_range` -- $file
            elif [[ $range[1] -le $last_line ]]; then
                range="$range[1],$last_line"
                git blame -s -b --root --no-progress -L $range `rev_range` -- $file
            fi
        done
        # Get the commit hash and prefix the line with 'L '.
    done) | grep -oE '^[a-z0-9]*' | sed 's/^/L /'
}

# List file matching commits prefixed with 'F '.
file_candidates() {
    # Iterate files which have been modified.
    (for file in `git diff --name-only --staged --diff-filter=M`; do
        git rev-list -n 4 -E `rev_range` -- $file
    done) | sed 's/^/F /'
}

# Output a formatted log of the match type and commit info.
print_candidate() {
    # Abbreviate the commit hash to its minimal required length.
    local readonly len=`git rev-parse --short HEAD | awk '{print length}'`
    git --no-pager log --format="%h |$1| %s - %an" --abbrev=$len -n 1 $2
}

# List the most recent unique candidate commits (limited to 4).
list_all_candidates() {
    if git diff --cached --quiet; then
        echo 'No staged changes.' >&2
        exit 1
    fi

    # Cd to the repo's top-level directory.
    cd "`git rev-parse --show-toplevel`"

    # Only take file candidates into account if no line candidates are found.
    local readonly l_candidates=`line_candidates`
    ((if [[ ! -z $l_candidates ]]; then
         echo $l_candidates
     else
         file_candidates
     fi) | while read match_type commit_sha; do
        print_candidate $match_type $commit_sha
    done) | awk '!seen[$1]++' | head -4
}

list_all_candidates
